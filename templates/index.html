<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2D 开奖系统</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<div class="container">
  <h1>2D</h1>
  <!-- 无“开奖”按钮，按时间自动开始 -->
  <div class="market-area" id="draw-area"></div>
</div>

<script>
// ===== 工具：日期与市场 =====
function pad(n){ return n.toString().padStart(2,'0'); }

const markets = [
  { code: 'M', name: 'Magnum',       color: '#ffff00', logo: 'magnum.png' },
  { code: 'P', name: 'Damacai',      color: '#0000ff', logo: 'damacai.png' },
  { code: 'T', name: 'SportsToto',   color: '#cc0000', logo: 'toto.png' },
  { code: 'S', name: 'Singapore',    color: '#4c8ed1', logo: 'singapore.png' },
  { code: 'H', name: 'Grand Dragon', color: '#ff0000', logo: 'grand_dragon.png' },
  { code: 'E', name: '9 Lotto',      color: '#ffa500', logo: '9lotto.png' },
  { code: 'B', name: 'Sabah',        color: '#e51d20', logo: 'sabah.png' },
  { code: 'K', name: 'Sandakan',     color: '#008835', logo: 'sandakan.png' },
  { code: 'W', name: 'Sarawak',      color: '#00540e', logo: 'sarawak.png' }
];

// 每个市场的定时器，避免重复
const timers = {}; // { M: [], ... }
function clearTimersFor(code){ (timers[code] || []).forEach(id => clearTimeout(id)); timers[code] = []; }
function addTimer(code, id){ if (!timers[code]) timers[code] = []; timers[code].push(id); }

// ===== 期号/时间段（固定 HH50）=====
function formatCode(dateObj, hour){  // -> "YYYYMMDD/HH50"
  const y = dateObj.getFullYear(), m = pad(dateObj.getMonth()+1), d = pad(dateObj.getDate());
  return `${y}${m}${d}/${pad(hour)}50`;
}

/**
 * 活跃区间与期号：
 * [H:51:00, (H+1):39:59] 读取 YYYYMMDD/H50
 * [H:40:00, H:50:59] 空白等待（不取数）
 * 返回 { code: "YYYYMMDD/HH50"|null, elapsed: 秒(从 H:51:00 起), blank: 是否空白期 }
 */
function computeFixedCodeAndElapsed(now = new Date()){
  const h = now.getHours(), m = now.getMinutes();
  const base = new Date(now); base.setSeconds(0,0);

  if (m >= 40 && m < 51) return { code: null, elapsed: 0, blank: true }; // 空白期

  if (m >= 51){
    const start = new Date(base); start.setHours(h, 51, 0, 0);
    return { code: formatCode(base, h), elapsed: (now - start)/1000, blank: false };
  }

  // m < 40 的活跃期，使用上一小时
  const codeDate = new Date(base);
  const codeHour = (h + 23) % 24;
  if (h === 0) codeDate.setDate(codeDate.getDate() - 1);
  const start = new Date(base);
  if (h === 0) start.setDate(start.getDate() - 1);
  start.setHours(codeHour, 51, 0, 0);
  return { code: formatCode(codeDate, codeHour), elapsed: (now - start)/1000, blank: false };
}

// 空白期也要在抬头显示“上一期的小时”
function getHeaderCodeForNow(){
  const r = computeFixedCodeAndElapsed(new Date());
  if (r.code) return r.code;
  const now = new Date();
  const prev = new Date(now); prev.setHours(now.getHours()-1, 0, 0, 0);
  return formatCode(prev, prev.getHours());
}

// 将 code 转成“Sun 31 Aug 2025/09”
function labelFromCode(code){
  if (!code) return '';
  const [ymd, hhmm] = code.split('/');
  const y = parseInt(ymd.slice(0,4),10), m = parseInt(ymd.slice(4,6),10)-1, d = parseInt(ymd.slice(6,8),10);
  const dt = new Date(y, m, d);
  const dateStr = dt.toLocaleDateString('en-GB', { weekday: 'short', day: '2-digit', month: 'short', year: 'numeric' }).replace(',', '');
  const hour = hhmm.slice(0,2); // "09"
  return `${dateStr}/${hour}`;
}

function updateHeaderDateHour(code){
  const label = labelFromCode(code);
  markets.forEach(m => {
    const span = document.getElementById(`datehour-${m.code}`);
    if (span) span.textContent = label;
  });
}

// 下一次 :40 的剩余毫秒
function millisToNext40s(){
  const now = new Date();
  const t = new Date(now);
  t.setMinutes(40, 0, 0);
  if (now >= t) t.setHours(t.getHours() + 1);
  return t - now;
}

// ===== 页面启动 =====
window.onload = () => {
  const container = document.getElementById('draw-area');
  const whiteTextMarkets = ['P', 'T', 'S', 'H', 'B', 'K', 'W'];  // 白字市场

  const initLabel = labelFromCode(getHeaderCodeForNow());

  markets.forEach(market => {
    const textColor = whiteTextMarkets.includes(market.code) ? 'white' : 'black';
    const box = document.createElement('div');
    box.className = 'draw-box';
    box.id = `draw-box-${market.code}`;
    box.innerHTML = `
      <div class="market-header" style="background-color: ${market.color}; color: ${textColor};">
        <img src="/static/${market.logo}" alt="${market.name}" class="market-logo">
        <div class="market-title">
          <div><strong>${market.name} 2D</strong></div>
          <div>( <span id="datehour-${market.code}">${initLabel}</span> )</div>
        </div>
      </div>
      <div class="section-title">1st Prize</div>
      <div class="result-table">
        <div class="result-box blank" id="odd-even-${market.code}">--</div>
        <div class="result-box blank" id="head-${market.code}">--</div>
        <div class="result-box blank" id="big-small-${market.code}">--</div>
      </div>
      <div class="section-title">Special Prize</div>
      <div class="result-table" style="grid-template-columns: repeat(3, 1fr);" id="special-${market.code}">
        ${Array.from({length: 3}).map((_, i) => `<div class="result-box blank" id="special-${market.code}-${i}">--</div>`).join('')}
      </div>
    `;
    container.appendChild(box);
  });

  runCycleOnce();      // 立即按当前规则运行一次
  scheduleNext51();    // 每小时 :51 开始新一轮并更新抬头
  scheduleClearAt40(); // 每小时 :40 清空
};

// ===== 清空/调度 =====
function clearAllUI() {
  markets.forEach(m => {
    clearTimersFor(m.code);
    const ids = [
      `odd-even-${m.code}`, `head-${m.code}`, `big-small-${m.code}`,
      `special-${m.code}-0`, `special-${m.code}-1`, `special-${m.code}-2`
    ];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) { el.textContent = '--'; el.classList.add('blank'); }
    });
  });
}

function scheduleClearAt40() {
  const loop = () => {
    const now = new Date();
    const target = new Date(now);
    target.setMinutes(40, 0, 0);
    if (now >= target) target.setHours(target.getHours() + 1);
    const ms = target - now;
    setTimeout(() => {
      clearAllUI(); // 任意小时 :40 清空
      // 清空时抬头仍显示上一期小时，不改动
      loop();
    }, ms);
  };
  loop();
}

function scheduleNext51() {
  const loop = () => {
    const now = new Date();
    const target = new Date(now);
    target.setHours(now.getMinutes() >= 51 ? now.getHours() + 1 : now.getHours(), 51, 0, 0);
    const ms = target - now;
    setTimeout(() => {
      // 进入新一轮：更新抬头的日期/小时；开始播放
      const headerCode = getHeaderCodeForNow();
      updateHeaderDateHour(headerCode);
      runCycleOnce();
      loop();
    }, ms);
  };
  loop();
}

// ===== 一轮（固定 code + 0/10/20/30 演示）=====
function runCycleOnce(){
  const { code, elapsed, blank } = computeFixedCodeAndElapsed(new Date());
  if (code) updateHeaderDateHour(code);           // 活跃期同步抬头
  if (blank || !code) { clearAllUI(); return; }   // 空白期：不取数
  startDraw(code, true, elapsed);
}

async function fetchDrawWithRetry(marketCode, code, maxRetrySec=60, intervalSec=2){
  const to40 = Math.max(0, Math.floor(millisToNext40s()/1000) - 1);
  const deadline = Date.now() + Math.min(maxRetrySec, to40) * 1000;

  while (Date.now() < deadline) {
    try {
      const res = await fetch(`/draw?market=${marketCode}&code=${encodeURIComponent(code)}&strict=1`);
      const data = await res.json();
      const specials = ((data.special || data.specials || [])).filter(Boolean);
      if ((specials && specials.length) || (data.head && data.head !== '')) return data;
    } catch (_) {}
    await new Promise(r => setTimeout(r, intervalSec * 1000));
  }
  try {
    const res = await fetch(`/draw?market=${marketCode}&code=${encodeURIComponent(code)}&strict=1`);
    return await res.json();
  } catch (_) { return {}; }
}

function startDraw(fixedCode, showImmediateFirst = true, elapsedSec = 0) {
  markets.forEach(async (market) => {
    clearTimersFor(market.code);
    resetBoxes(market.code);

    const data = await fetchDrawWithRetry(market.code, fixedCode, 60, 2);

    const headFromServer = (data.head != null && data.head !== '') ? parseInt(data.head, 10) : null;
    const nums = ((data.special || data.specials || [])).slice(0, 3).map(n => n.toString().padStart(2, '0'));

    // 09:51 起：t=0→10→20→30
    const e = Math.max(0, elapsedSec || 0);
    let shown = 0;
    if (nums.length > 0) {
      if (e >= 0)  shown = 1;
      if (e >= 10) shown = 2;
      if (e >= 20) shown = 3;
    }
    for (let k = 0; k < shown; k++) showSpecial(market.code, k, nums[k]);

    if (e >= 30) { renderHeadAndTypes(market.code, headFromServer, nums, data); return; }

    const scheduleAt = (targetSec, fn) => {
      const delay = Math.max(0, targetSec - e) * 1000;
      addTimer(market.code, setTimeout(fn, delay));
    };
    if (shown === 0 && nums.length > 0) {
      if (showImmediateFirst) showSpecial(market.code, 0, nums[0]);
      else scheduleAt(0, () => showSpecial(market.code, 0, nums[0]));
    }
    if (nums.length > 1 && shown <= 1) scheduleAt(10, () => showSpecial(market.code, 1, nums[1]));
    if (nums.length > 2 && shown <= 2) scheduleAt(20, () => showSpecial(market.code, 2, nums[2]));
    scheduleAt(30, () => renderHeadAndTypes(market.code, headFromServer, nums, data));
  });
}

// ===== UI 渲染 =====
function resetBoxes(code){
  for (let j = 0; j < 3; j++) {
    const s = document.getElementById(`special-${code}-${j}`);
    s.textContent = '--'; s.classList.add('blank');
  }
  const headBox = document.getElementById(`head-${code}`);
  const oddEven = document.getElementById(`odd-even-${code}`);
  const bigSmall = document.getElementById(`big-small-${code}`);
  headBox.textContent = '--'; oddEven.textContent = '--'; bigSmall.textContent = '--';
  headBox.classList.add('blank'); oddEven.classList.add('blank'); bigSmall.classList.add('blank');
}

function showSpecial(code, idx, val) {
  const el = document.getElementById(`special-${code}-${idx}`);
  if (!el) return;
  el.textContent = val;
  el.classList.remove('blank');
}

function renderHeadAndTypes(code, headFromServer, nums, data) {
  const headBox = document.getElementById(`head-${code}`);
  const oddEven = document.getElementById(`odd-even-${code}`);
  const bigSmall = document.getElementById(`big-small-${code}`);
  const chosen = (headFromServer !== null)
    ? headFromServer
    : (nums.length ? parseInt(nums[Math.floor(Math.random() * nums.length)], 10) : NaN);

  if (!Number.isNaN(chosen)) {
    headBox.textContent = chosen.toString().padStart(2, '0');
    headBox.classList.remove('blank');

    // 正确判断后端字段
    oddEven.textContent = (data.parity && (data.parity === '单' || data.parity === '双'))
      ? data.parity
      : (chosen % 2 === 0 ? '双' : '单');
    oddEven.classList.remove('blank');

    bigSmall.textContent = (data.size && (data.size === '大' || data.size === '小'))
      ? data.size
      : (chosen >= 50 ? '大' : '小');
    bigSmall.classList.remove('blank');

    // 若头奖与某个 special 相同，则清空该格
    for (let j = 0; j < 3; j++) {
      const s = document.getElementById(`special-${code}-${j}`);
      if (s && s.textContent === chosen.toString().padStart(2, '0')) {
        s.textContent = '--';
        s.classList.add('blank');
        break;
      }
    }
  } else {
    headBox.textContent = 'ERR';
    headBox.classList.remove('blank');
  }
}
</script>
</body>
</html>
